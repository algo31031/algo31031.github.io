<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 老男孩的整理箱]]></title>
  <link href="http://blog.banban.me/blog/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.banban.me/blog/"/>
  <updated>2015-09-28T09:31:23+08:00</updated>
  <id>http://blog.banban.me/blog/</id>
  <author>
    <name><![CDATA[banban]]></name>
    <email><![CDATA[algo31031@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby下的 ===, ==, Eql?, Equal?]]></title>
    <link href="http://blog.banban.me/blog/blog/2014/05/14/rubyxia-de-equals-equals-equals/"/>
    <updated>2014-05-14T16:18:04+08:00</updated>
    <id>http://blog.banban.me/blog/blog/2014/05/14/rubyxia-de-equals-equals-equals</id>
    <content type="html"><![CDATA[<h3>=== case equality</h3>

<p>严格说来, 这个其实跟另外三个不属于一类.</p>

<p><code>a === b</code> 相当于 &ldquo;如果我有一个贴了a标签的抽屉, 那么把b放到这个抽屉里是否可行?&rdquo;</p>

<p>作为case equality operator, 其首要作用自然是在<code>when/case</code>里, 作为判断进入某个分支的依据</p>

<pre><code class="ruby">a = 5

case a
when Integer
  "case Integer"
when 5
  "case 5"
end
</code></pre>

<p>这段代码其实是会返回<code>"case Integer"</code>的, 因为<code>Integer</code>类重写了<code>===</code>方法
<code>irb
2.1.1 :043 &gt; Integer === 5
 =&gt; true
</code></p>

<p>相应的, 重写了<code>===</code>的还有<code>Range</code>, <code>Regexp</code>等等
<code>irb
2.1.1 :054 &gt; (1..5) === 5
 =&gt; true
2.1.1 :055 &gt; (1...5) === 5
 =&gt; false
2.1.1 :058 &gt; /(a|e|i|o|u)/ === "hello"
 =&gt; true  
</code></p>

<p>对于<code>Object#===</code>, 事实上等价于<code>Object#==</code>.<br/>
但是对Object的子类, <code>===</code>一般会被重写, 使其在条件表达式里有意义.</p>

<p>这里可以拿<code>&lt;=&gt;</code>方法做个类比</p>

<p>比如我们自己定义了个<code>User</code>类, 如果直接就<code>User.all.sort</code>, 是不可以的,<br/>
如果想这么用, 你就需要首先在<code>User</code>里面定义一个<code>&lt;=&gt;</code>方法用于比较2个user对象</p>

<p>稍微有点不同的是, 因为<code>===</code>是定义在<code>Object</code>里的<br/>
所以即便对自己定义的类里面不重写<code>===</code>方法, 一样可以对其使用<code>case/when</code><br/>
但是这样会调用Object#===, 可能不会得到自定义类需要的结果.</p>

<p>依然用上面的例子来说
如果<code>Integer</code>里面没有重写<code>===</code>方法, 那么得到的返回值就不再是"case Integer",而是"case 5"了</p>

<h3>==</h3>

<p><code>==</code>是最为常用的用于比较两个对象值是否相等的方法</p>

<p><code>a == b</code>相当于判断"a的值与b的值相同吗"</p>

<p><code>==</code>方法经常被Object子类重写以满足其自身需求</p>

<h3>equal?</h3>

<p><code>equal?</code>方法用来判断2个对象是否是同一个对象</p>

<p><code>a.equal? b</code>相当于判断"a就是b吗"</p>

<pre><code class="irb">2.1.1 :005 &gt; "a" == "a"
 =&gt; true 
2.1.1 :006 &gt; "a".equal? "a"
 =&gt; false 
2.1.1 :007 &gt; :a.equal? :a
 =&gt; true 
</code></pre>

<p>与<code>==</code>不同, <code>equal?</code>不应该被子类重写</p>

<h3>eql?</h3>

<p>与<code>==</code>类似, 但是可以看做是更严格的<code>==</code><br/>
在<code>Object</code>里, <code>==</code>与<code>eql?</code>是同意, 但是很多子类会重写<code>eql?</code>以提供更严格的比较, 比如:
<code>irb
2.1.1 :010 &gt; 1 == 1
 =&gt; true
2.1.1 :011 &gt; 1 == 1.0
 =&gt; true
2.1.1 :012 &gt; 1.eql? 1.0
 =&gt; false
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为class Method添加alias_method]]></title>
    <link href="http://blog.banban.me/blog/blog/2014/05/13/wei-class-methodtian-jia-alias-method/"/>
    <updated>2014-05-13T16:21:15+08:00</updated>
    <id>http://blog.banban.me/blog/blog/2014/05/13/wei-class-methodtian-jia-alias-method</id>
    <content type="html"><![CDATA[<pre><code class="ruby ">class ChatTeamTopic &lt; ActiveRecord::Base
  acts_as_paranoid

  ...

  class &lt;&lt; self
    alias_method :orig_delete_all, :delete_all

    def delete_all(conditions = nil)
      clear_notifications(conditions) if conditions.present?
      orig_delete_all(conditions)
    end

    def clear_notifications(conditions)
      ...
    end
  end

  ...

end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby编程风格(节选)]]></title>
    <link href="http://blog.banban.me/blog/blog/2014/04/22/rubybian-cheng-feng-ge/"/>
    <updated>2014-04-22T14:47:21+08:00</updated>
    <id>http://blog.banban.me/blog/blog/2014/04/22/rubybian-cheng-feng-ge</id>
    <content type="html"><![CDATA[<p>平时还是挺注意格式问题的, 不过看来还是有好多地方需要改进<br/>
从ruby-china wiki那边抄录了些平时欠缺的coding style, 日后多加注意</p>

<h3>源代码布局</h3>

<ul>
<li>对于没有内容的类定义，尽可能使用单行类定义形式.
``` ruby

<h1>bad</h1>

<p>class FooError &lt; StandardError
end</p></li>
</ul>


<h1>okish</h1>

<p>class FooError &lt; StandardError; end</p>

<h1>good</h1>

<p>FooError = Class.new(StandardError)
```</p>

<ul>
<li>避免单行方法。即便还是会受到一些人的欢迎，这里还是会有一些古怪的语法用起来很容易犯错.<br/>
  无论如何 - 应该一行不超过一个单行方法.<br/>
  但是<strong>空方法</strong>例外
``` ruby

<h1>good</h1>

<p>def some_method
body
end</p></li>
</ul>


<h1>good</h1>

<p>def no_op; end
```</p>

<ul>
<li>当赋值一个条件表达式的结果给一个变量时，保持分支的缩排在同一层。
``` ruby

<h1>bad - pretty convoluted</h1>

<p>kind = case year
when 1850..1889 then &lsquo;Blues&rsquo;
when 1890..1909 then &lsquo;Ragtime&rsquo;
when 1910..1929 then &lsquo;New Orleans Jazz&rsquo;
when 1930..1939 then &lsquo;Swing&rsquo;
when 1940..1950 then &lsquo;Bebop&rsquo;
else &lsquo;Jazz&rsquo;
end</p></li>
</ul>


<p>result = if some_cond
  calc_something
else
  calc_something_else
end</p>

<h1>good - it&rsquo;s apparent what&rsquo;s going on</h1>

<p>kind = case year
       when 1850..1889 then &lsquo;Blues&rsquo;
       when 1890..1909 then &lsquo;Ragtime&rsquo;
       when 1910..1929 then &lsquo;New Orleans Jazz&rsquo;
       when 1930..1939 then &lsquo;Swing&rsquo;
       when 1940..1950 then &lsquo;Bebop&rsquo;
       else &lsquo;Jazz&rsquo;
       end</p>

<p>result = if some_cond
           calc_something
         else
           calc_something_else
         end</p>

<h1>good (and a bit more width efficient)</h1>

<p>kind =
  case year
  when 1850..1889 then &lsquo;Blues&rsquo;
  when 1890..1909 then &lsquo;Ragtime&rsquo;
  when 1910..1929 then &lsquo;New Orleans Jazz&rsquo;
  when 1930..1939 then &lsquo;Swing&rsquo;
  when 1940..1950 then &lsquo;Bebop&rsquo;
  else &lsquo;Jazz&rsquo;
  end</p>

<p>result =
  if some_cond
    calc_something
  else
    calc_something_else
  end
```</p>

<ul>
<li>当给方法的参数赋默认值时，在 = 两边使用空格
``` ruby

<h1>bad</h1>

def some_method(arg1=:default, arg2=nil, arg3=[])

<h1>do something&hellip;</h1>

<p>end</p></li>
</ul>


<h1>good</h1>

<p>def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something&hellip;
end
```</p>

<ul>
<li>大数值添加下划线来提高它们的可读性。
``` ruby

<h1>bad - how many 0s are there?</h1>

<p>num = 1000000</p></li>
</ul>


<h1>good - much easier to parse for the human brain</h1>

<p>num = 1_000_000
```</p>

<ul>
<li>每一行限制在 80 个字符内。</li>
</ul>


<h3>语法</h3>

<ul>
<li>避免在不需要的地方使用 self(它仅仅在调用一些 self 做写访问的时候需要)
  (It is only required when calling a self write accessor.)
``` ruby

<h1>bad</h1>

<p>def ready?
if self.last_reviewed_at > self.last_updated_at
  self.worker.update(self.content, self.options)
  self.status = :in_progress
end
self.status == :verified
end</p></li>
</ul>


<h1>good</h1>

<p>def ready?
  if last_reviewed_at > last_updated_at
    worker.update(content, options)
    self.status = :in_progress
  end
  status == :verified
end
```</p>

<ul>
<li>不要在条件表达式里使用 = （赋值）的返回值，除非条件表达式在圆括号内被赋值。
  这是一个相当流行的 ruby 方言，有时被称为 safe assignment in condition。
``` ruby

<h1>bad (+ a warning)</h1>

<p>if v = array.grep(/foo/)
do_something(v)
&hellip;
end</p></li>
</ul>


<h1>good (MRI would still complain, but RuboCop won&rsquo;t)</h1>

<p>if (v = array.grep(/foo/))
  do_something(v)
  &hellip;
end</p>

<h1>good</h1>

<p>v = array.grep(/foo/)
if v
  do_something(v)
  &hellip;
end
```</p>

<ul>
<li>用 proc 而不是 Proc.new。</li>
</ul>


<pre><code class="ruby"># bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }
</code></pre>

<h3>类与模块</h3>

<ul>
<li><p>在 class 定义里使用一致的结构。
``` ruby
class Person</p>

<h1>extend and include go first</h1>

<p>extend SomeModule
include AnotherModule</p>

<h1>constants are next</h1>

<p>SOME_CONSTANT = 20</p>

<h1>afterwards we have attribute macros</h1>

<p>attr_reader :name</p>

<h1>followed by other macros (if any)</h1>

<p>validates :name</p>

<h1>public class methods are next in line</h1>

<p>def self.some_method
end</p>

<h1>followed by public instance methods</h1>

<p>def some_method
end</p>

<h1>protected and private methods are grouped near the end</h1>

<p>protected</p>

<p>def some_protected_method
end</p>

<p>private</p>

<p>def some_private_method
end
end
```</p></li>
<li><p>倾向使用 module，而不是只有类方法的 class。类别应该只在创建实例是合理的时候使用。
``` ruby</p>

<h1>bad</h1>

<p>class SomeClass
def self.some_method
  # body omitted
end</p>

<p>def self.some_other_method
end
end</p></li>
</ul>


<h1>good</h1>

<p>module SomeClass
  module_function</p>

<p>  def some_method
    # body omitted
  end</p>

<p>  def some_other_method
  end
end
```</p>

<ul>
<li>当你希望将模块的实例方法变成 class 方法时，偏爱使用 module_function 胜过 extend self。</li>
</ul>


<h3>集合</h3>

<ul>
<li>用 Hash#key? 不用 Hash#has_key? 以及用 Hash#value?, 不用 Hash#has_value?<br/>
  Matz 提到过 长的形式在考虑被弃用。
```ruby

<h1>bad</h1>

<p>hash.has_key?(:test)
hash.has_value?(value)</p></li>
</ul>


<h1>good</h1>

<p>hash.key?(:test)
hash.value?(value)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 里的 %Q, %q, %W, %w, %x, %r, %s, %i(译)]]></title>
    <link href="http://blog.banban.me/blog/blog/2014/04/10/percent-q-percent-q-percent-w-percent-w-percent-x-percent-r-percent-s-percent-i/"/>
    <updated>2014-04-10T09:54:28+08:00</updated>
    <id>http://blog.banban.me/blog/blog/2014/04/10/percent-q-percent-q-percent-w-percent-w-percent-x-percent-r-percent-s-percent-i</id>
    <content type="html"><![CDATA[<p><a href="http://simpleror.wordpress.com/2009/03/15/q-q-w-w-x-r-s/">原文地址</a></p>

<h3>%Q</h3>

<p>用于替代双引号的字符串. 当你需要在字符串里放入很多引号时候, 可以直接用下面方法而不需要在引号前逐个添加反斜杠 (\&ldquo;)</p>

<pre><code>&gt;&gt; %Q(Joe said: "Frank said: "#{what_frank_said}"")
=&gt; "Joe said: "Frank said: "Hello!"""
</code></pre>

<p><code>(</code>&hellip;<code>)</code>也可用其他非数字字母的符号或成对的符号代替, 诸如<code>[</code>&hellip;<code>]</code>, <code>!</code>&hellip;<code>!</code>, <code>+</code>&hellip;<code>+</code>,<code>{</code>&hellip;<code>}</code>, <code>&lt;</code>&hellip;<code>&gt;</code>等.<br/>
以下写法全部与上面等效:</p>

<pre><code>&gt;&gt; %Q!Joe said: "Frank said: "#{what_frank_said}""!
&gt;&gt; %Q[Joe said: "Frank said: "#{what_frank_said}""]
&gt;&gt; %Q+Joe said: "Frank said: "#{what_frank_said}""+     
</code></pre>

<p>除此之外还可省略<code>Q</code>写作:</p>

<pre><code>&gt;&gt; %/Joe said: "Frank said: "#{what_frank_said}""/
=&gt; "Joe said: "Frank said: "Hello!""" 
</code></pre>

<h3>%q</h3>

<p>与<code>%Q</code>类似, 但是表示的是单引号字符串</p>

<pre><code>&gt;&gt; %q(Joe said: 'Frank said: '#{what_frank_said} ' ')
=&gt; "Joe said: 'Frank said: '\#{what_frank_said} ' '"    
</code></pre>

<h3>%W</h3>

<p>语法近似于<code>%Q</code>, 用于表示其中元素被双引号括起的数组.</p>

<pre><code>&gt;&gt; %W(#{foo} Bar Bar\ with\ space)
=&gt; ["Foo", "Bar", "Bar with space"] 
</code></pre>

<h3>%w</h3>

<p>用于表示其中元素被单引号括起的数组. 比较奇怪的是<code>\</code>(斜杠空格)会被转化成<code></code>(空格), 但是其他的内容不会.</p>

<pre><code>&gt;&gt; %w(a b c\ d \#e #{1}f)
=&gt; ["a", "b", "c d", "\\#e", "\#{1}f"]
</code></pre>

<h3>%x</h3>

<p>使用```方法执行一段shell脚本并返回标准输出内容.</p>

<pre><code>&gt;&gt; %x(echo foo:#{foo})
=&gt; "foo:Foo\n"    
</code></pre>

<h3>%r</h3>

<p>语法近似于<code>%Q</code>, 用于正则表达式.</p>

<pre><code>&gt;&gt; %r(/home/#{foo})
=&gt; "/\\/home\\/Foo/"     
</code></pre>

<h3>%s</h3>

<p>用于表示symbol, 但是不会对其中表达式等内容进行转化</p>

<pre><code>&gt;&gt; %s(foo)
=&gt; :foo
&gt;&gt; %s(foo bar)
=&gt; :"foo bar"
&gt;&gt; %s(#{foo} bar)
=&gt; :"\#{foo} bar"
</code></pre>

<h3>%i</h3>

<p>Ruby 2.0 之后引入的语法, 用于生成一个symbol数组</p>

<pre><code>2.0.0p247 :014 &gt; %i(a b c)
=&gt; [:a, :b, :c] 
</code></pre>
]]></content>
  </entry>
  
</feed>
